# 上周学习总结

* C语言学习结束

* 各种奇奇怪怪的新生赛

* ret2csu，栈迁移初步了解

* vscode ssh远程连接虚拟机环境搭建（但这两天vscode有点不好使，得收拾收拾）

  ## C语言学习补充

  c语言的学习接近了尾声，但这一遍的c语言并没有学到多么深，主要是因为留给pwn的时间真的不多了，主要以能看懂代码为主，在学过汇编语言，栈和堆之后会回头重新学习C语言和Linux指令，感觉有点心急了，但对于我如白纸一般的大脑，估计不管学啥它的色彩都会丰富一些吧。

  以下是辽宁考生第一轮C语言学习的补充：

  >数组的本质就是同时定义多个变量并对他们初始化，当字符数组的最后一个变量为\0的时候这就是一个字符串，而数组又是一个抽象的概念，它把很多变量都存到了一个集合里，这就导致数组也存在指针的性质
  >
  >所以，字符串可以写成
  >
  >>char ch[6]="hello"(字母o后面有一个空字符，所以下标为6)
  >>
  >>char ch[]="hello"(完整定义时也可以不写下标，系统会自行运算)
  >>
  >>char *ch(用指针的方式定义数组)
  >
  >但以上用指针声明和用数声明是有区别的，ch[]中，ch保存了数组的第一个字母的地址（这也是为什么我说数组有指针的性质），但这是数组名而不是一个指针，所以ch不可赋值(也就是人们经常提及到的数组字面量没法修改)，但是用指针声明可以让指针加减指向不同地址的字符
  >
  >但是我们要分清一个问题，以上内容只针对ch，而不是ch[]，用ch[1]当然是可以在非静态变量或者全局变量的情况下改变数组的第二位字符，但我们讨论的是ch(字面量/指针)

记到这里就不得不讲一些笔者上周所学习到的比较底层的东西了，指针形式的ch是一个局部变量，储存在栈中，而他所指向的内容储存在常量区，但是ch[]定义的字符数组和ch都储存在栈中(再次补充，栈段存放的是函数调用相关的参数和局部变量的值)

## 奇奇怪怪的新生赛

* 蟑螂学长

  ELF之后发现一片绿色（保护全开），两种选择，要么放弃要么审计

  审了十分钟，终于在一个分支中发现了system(/bin/sh)

  接下来直接nc然后慢慢解就好啦

* ret2text

  其实这道题不难，只是因为全局搜索之后会找到好多段都出现了system调用和/bin/sh，不知道从哪里下手，但后来了解到cancanneed=看看你的之后我才知道pwn这些类型的意思ret2text=返回到text段的代码，于是最后直接栈溢出覆盖返回地址然后返回到text段的system

* ret2libc

  做了四道，就出来两道，但问题都出在真实地址没有泄露出来（gdbgdbgdb哭）

  有libc文件就不用LibcSearcher

  泄露出真实地址之后直接解析文件然后libc.sym['']

  没有的话就用一下然后Searcher一下看看适配的libc库，装一下然后libc.sym['']就欧克了

目前还是没见过ret2syscall，期待期待(吐槽一下sictf，啥啥都十多解，pwn的签到题四五百个人就七个人做出来了，出题人**************)

## pwn的学习嘿嘿

* ret2csu

  简单来说就是ret2libc plus，一般我们去找pop rdi还有其他寄存器的时候都需要ROPgadget，但如果需要的寄存器太多（我也不知道为啥需要这么多的寄存器，可能未来遇到题的时候才会知道），这时候我们就可以研究研究一个64位程序基本都有的一个函数__libc_csu_init

```bush
.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j
.text:0000000000400600                 mov     rdx, r13
.text:0000000000400603                 mov     rsi, r14
.text:0000000000400606                 mov     edi, r15d
.text:0000000000400609                 call    qword ptr [r12+rbx*8]
.text:000000000040060D                 add     rbx, 1
.text:0000000000400611                 cmp     rbx, rbp
.text:0000000000400614                 jnz     short loc_400600
.text:0000000000400616
.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j
.text:0000000000400616                 add     rsp, 8
.text:000000000040061A                 pop     rbx
.text:000000000040061B                 pop     rbp
.text:000000000040061C                 pop     r12
.text:000000000040061E                 pop     r13
.text:0000000000400620                 pop     r14
.text:0000000000400622                 pop     r15
.text:0000000000400624                 retn
.text:0000000000400624 __libc_csu_init endp

```

在loc_400616中我们可以控制rbx,rbp,r12,r13,r14,r15(pop指令将栈顶弹入寄存器)
在loc_400600中我们可以控制rdx,rsi,edi（间接通过r13,r14,r15来控制），而这里的rdx,rsi,edi正好是函数的前三个参数所需寄存器，不过edi只能控制函数的低32位，但也足以应付大部分函数

所以我们只需要先控制主函数返回到loc_400616，并在栈上从前往后构造每个寄存器想要赋予的值，然后在loc_400624对应的栈填上loc_400600，跳转到这一部分，通过刚才各寄存器构造的参数来给rdx,rsi,edi赋值，在loc_400609运行想要执行的函数，即可成功执行。

* 栈迁移

  又叫伪造栈帧，其实就是两次利用ret和leave将rsp和rbp移动到自己想要的地方，比如某个被写入shellcode的地方

  好啦就这些啦，实操的话等学一点汇编再整吧（没基础真不行啊，看帖子好像高中上地理课一样）

## 下周学习计划

开始深层次学习我的栈堆（当然，认真学习汇编也是必不可少的）

青少年强网杯

isctf（希望出题人不是T1d师傅）

# 总结

任重而道远，多学习，少装逼，静下心来