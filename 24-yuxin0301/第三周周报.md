:::info
💡  字多 ≠ 有价值

      周报不是为了表现工作量，而是给团队提供最基本的“信息透明”。尽量挑选重要信息来写。

:::



汇报人：王宇忻

日期：2024-10-28到2024-11-03

## 本周重点
### 1.任务进展
> 本周完成了哪些任务、整体进度如何。
>

本周学习了python，研究了RSA的几个脚本

### 2.相关数据
**周一：做题并同时学习RSA**

**1.收集到一个分解素数的脚本**

```plain
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5)+1):
        if n % i == 0:
            return False
    return True

def prime_factorization(n):
    factors = []
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors

num = int(input("请输入一个正整数："))
result = prime_factorization(num)
print(f"{num}分解为素数乘积为：{' * '.join(map(str, result))}")
```



**2.p，q大小接近的RSA脚本**

以这道题为例

```plain
n= 12872311844796335551074772926373442157584207393868495851604773915402573049905020786883935496452654953182028422239889519866798473860330700762324494226757523208430629280963673244580900642802613477278622107025994098955715529159364503684996390392870614975557242855553151220373699874977684957792556070396045575585134086316066211567151217961741210892593858681987222776416960335601990219681817959094253930024878375582517316502091321736391906696168378868287901493175466496043572325201642173497838277126933218828358564443772474000457448713435536967737757982044937175519657867854547932884151120179002864724013116653807902692637
e= 65537
c= 9132582410761466193897393860943366992045516908322696055882421527052610500121891193136852494077311298577641886692181159438065660446662754105849323312928620489217571402954575229902509545202861138414515107447794944344598744230530961197099220658114404726362543877191904637729863906963841100167814779606979014982383413687565793725075500441872139157678937789220295680934581953982434770689821811167304885893774840050051446190132541313031028882692122429222790715135491595434135834488277926897887734937555589905152137558556293999414724378085536870794501987540152168612980967420475826314881377426621602225280131752264612573606
```

题目给出的提示‘pq怎么离的这么近呢’的提示编写代码

```plain
from Crypto.Util.number import *
from gmpy2 import *
n= 12872311844796335551074772926373442157584207393868495851604773915402573049905020786883935496452654953182028422239889519866798473860330700762324494226757523208430629280963673244580900642802613477278622107025994098955715529159364503684996390392870614975557242855553151220373699874977684957792556070396045575585134086316066211567151217961741210892593858681987222776416960335601990219681817959094253930024878375582517316502091321736391906696168378868287901493175466496043572325201642173497838277126933218828358564443772474000457448713435536967737757982044937175519657867854547932884151120179002864724013116653807902692637
e= 65537
c= 9132582410761466193897393860943366992045516908322696055882421527052610500121891193136852494077311298577641886692181159438065660446662754105849323312928620489217571402954575229902509545202861138414515107447794944344598744230530961197099220658114404726362543877191904637729863906963841100167814779606979014982383413687565793725075500441872139157678937789220295680934581953982434770689821811167304885893774840050051446190132541313031028882692122429222790715135491595434135834488277926897887734937555589905152137558556293999414724378085536870794501987540152168612980967420475826314881377426621602225280131752264612573606
sqr =iroot(n,2)[0]
for i in range (10000):
    if n %(sqr + i ) == 0:
        p = sqr + i
        q = n//p
        break
d = invert(e,(p-1)*(q-1))
print(long_to_bytes(powmod(c,d,n)))
```



**周二：继续学习密码学的RSA**

**1.Wiener攻击**

以此题为例：

```plain
import libnum
import random
import gmpy2

# 生成随机素数
p = libnum.generate_prime(512)
q = libnum.generate_prime(512)
m = "xjusec{fake_flag}"
# 字符串转数字
m = libnum.s2n(m)
n = p * q
phi_n = (p - 1) * (q - 1)
# 计算d
while True:
    nbits = 1024
    d = random.getrandbits(nbits // 4)
    if libnum.gcd(d, phi_n) == 1 and 36 * pow(d, 4) < n:
        break
# 计算e
e = libnum.invmod(d, phi_n)
c = pow(m, e, n)
print("n=", n)
print("e=", e)
print("c=", c)

'''
n= 84759586321367337887780437584685106579085074965112521484344049646437894046082602854634633148582472968603463743438343484823980031138129314219504095698178622254320271681999860332610325223454341809051178943622128336098505461927391262429524484667385743868165220569109483345920566095908674582795138002280172054901
e= 66288875417761391735336508179031781461458397094560594352005873830730369271057472593019640848396507956317226914042734460741730619378424621998873462267141804992425548349906362051377176848446970670269625959428657063813053998204432987906270288972553991694084764963674828882833521361595114819645054140098694014033
c= 55793266382808668383390028264320313476480462639251420282032620664514843264012556336628829925417590165117761221508016231889956332919056931672687301567732943226049335108323978513326330771724845198936862017830947882511017614192627520685625693006743832632002358777752259725470367349656504917200798619000646027705
'''
```

根据给定代码发现n和e比较接近，考虑进行Wiener攻击

```plain
from Crypto.Util.number import *
from gmpy2 import *

class ContinuedFraction():
    def __init__(self, numerator, denumerator):
        self.numberlist = []
        self.fractionlist = []
        # 修改这里，调用只接受两个参数的 GenerateNumberList 方法
        self.GenerateNumberList(numerator, denumerator)
        self.GenerateFractionList()

    def GenerateNumberList(self, numerator, denumerator):
        while numerator!= 1:
            quotient = numerator // denumerator
            remainder = numerator % denumerator
            self.numberlist.append(quotient)
            numerator = denumerator
            denumerator = remainder

    def GenerateFractionList(self):
        self.fractionlist.append([self.numberlist[0], 1])
        for i in range(1, len(self.numberlist)):
            numerator = self.numberlist[i]
            denumerator = 1
            for j in range(i):
                temp = numerator
                numerator = denumerator + numerator * self.numberlist[i - j - 1]
                denumerator = temp
            self.fractionlist.append([numerator, denumerator])

n = 84759586321367337887780437584685106579085074965112521484344049646437894046082602854634633148582472968603463743438343484823980031138129314219504095698178622254320271681999860332610325223454341809051178943622128336098505461927391262429524484667385743868165220569109483345920566095908674582795138002280172054901
e = 66288875417761391735336508179031781461458397094560594352005873830730369271057472593019640848396507956317226914042734460741730619378424621998873462267141804992425548349906362051377176848446970670269625959428657063813053998204432987906270288972553991694084764963674828882833521361595114819645054140098694014033
c = 55793266382808668383390028264320313476480462639251420282032620664514843264012556336628829925417590165117761221508016231889956332919056931672687301567732943226049335108323978513326330771724845198936862017830947882511017614192627520685625693006743832632002358777752259725470367349656504917200798619000646027705

a = ContinuedFraction(e, n)
for k, d in a.fractionlist:
    s = long_to_bytes(powmod(c, d, n))
    try:
        print(s.decode())
    except Exception:
        pass
```



**2.共模攻击**

<font style="color:rgb(35, 38, 59);">运用c1、c2、n、e1、e2计算出m脚本：</font>

```plain
from Crypto.Util.number import long_to_bytes
from gmpy2 import gcdext

c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361
n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801
e1=11187289
c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397
e2=9647291

_,s1,s2 = gcdext(e1,e2) #根据扩展欧几里得算法求出s1和s2，满足e1*s1+e2*s2 = 1。前方加上一个“_”说明我们忽略gcdext(e1,e2)返回的第一个值——最大公约数

m = pow(c1,s1,n) * pow(c2,s2,n) % n

print(long_to_bytes(m))
```



**周三：刷题,并继续收集RSA脚本**

**1.低加密指数攻击（小明文攻击）**

<font style="color:rgb(77, 77, 77);">e很小，n很大又不好分解</font>

<font style="color:rgb(77, 77, 77);">例题：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/49726404/1730289007702-8a64c990-30c7-4712-8d3d-6427dd34557f.png)

```plain
from Crypto.Util.number import *
from gmpy2 import *

e = 0x3
c = 0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365

print(long_to_bytes(iroot(c,e)[0]))
```

b'flag{25df8caf006ee5db94d48144c33b2c3b}'



**2.dikqTCpfRjA8fUBIMD5GNDkwMjNARkUwI0BFTg==**

Base64解密出来是一串乱码，还需要结合ROT47进行解密

![](https://cdn.nlark.com/yuque/0/2024/png/49726404/1730294485360-0d380dfe-069a-4219-9567-f0ca9928e38a.png)



**3.****<font style="color:rgb(33, 37, 41);">密码学的心声</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/49726404/1730294721068-7f38c0d1-63b8-404c-a953-3922e4331798.png)

上面给出了提示，这些简谱构成的数字是八进制的ASCII码值

```plain
from Crypto.Util.number import *
from gmpy2 import *

p = 262248800182277040650192055439906580479
q = 262854994239322828547925595487519915551
c = 27565231154623519221597938803435789010285480123476977081867877272451638645710
e = 65533

d = invert(e,(p-1)*(q-1))
m = powmod(c,d,p*q)

print(long_to_bytes(m))
```

![](https://cdn.nlark.com/yuque/0/2024/png/49726404/1730294929544-55af25e2-3d77-4019-a3dc-f92a6a194e62.png)



**4.**

![](https://cdn.nlark.com/yuque/0/2024/png/49726404/1730295370778-bd6ddaa7-a3fc-4656-9c82-fc85a554ba29.png)

有一点点离谱...

![](https://cdn.nlark.com/yuque/0/2024/png/49726404/1730295460246-16797e2b-04e0-4e2b-881b-c501968a5ef5.png)<font style="color:rgb(77, 77, 77);">playfair也是一个加密方式</font>

![](https://cdn.nlark.com/yuque/0/2024/png/49726404/1730295938448-4f0b423c-5cb8-47f1-9f92-a024106a630f.png)

将得到的转化为小写



**周四**

**1.****<font style="color:rgb(33, 37, 41);">[GUET-CTF2019]BabyRSA 1</font>**

```plain
p+q : 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea
(p+1)(q+1) : 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740
e : 0xe6b1bee47bd63f615c7d0a43c529d219
d : 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5
enc_flag : 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a
```

_<font style="color:rgb(77, 77, 77);">n = (p+1)</font>_<font style="color:rgb(77, 77, 77);">(q+1) - (p+q) - 1</font>

```plain
import libnum

# 假设给定这些值
p_plus_q = 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea
p_plus_q_plus_1 = 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740
e = 0xe6b1bee47bd63f615c7d0a43c529d219
d = 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5
c = 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a

# 计算 n
n = p_plus_q_plus_1 - p_plus_q - 1

# 计算 m
m = pow(c, d, n)

print(libnum.n2s(m))    #（n2s将数值转化为字符串）
```

![](https://cdn.nlark.com/yuque/0/2024/png/49726404/1730377060824-84426610-e4b0-46c2-88ed-d0e9f53f6f01.png)



**周五**

学习python...，并做SICTF



## 下周计划
> 接下来要做什么、是否需要其他协助。
>

下周开始学习数论，并继续学习C语言和python。







