# 完成事项
1. ISCTF（终于结束了）
2. 了解了bsgs算法

# 下周待做事项
1. 补先前没刷完的BUU
2. 复现ISCTF没做出的题
3. 周日的强网青少赛
4. 看python

# 本周学习的知识分享
## ISCTF
### 我和小蓝鲨的秘密
_<u>一点先前忘写了的感想：一开始照着加密代码写的解密代码，然后在RGB的赋值这一个语句上卡住了，因为加密代码里是[i,j,0]这类格式，我也就顺手复制粘贴了过来，然后就报错说我把整型数值切片了，换了几种格式也是这样，最后发现之间用[i,j]可以直接输出RGB三个数的值，不用单个单个的提取</u>_

照着加密代码写解密代码

```plain
import gmpy2 as gp
import numpy as np

p = 160216064374859
q = 186431677583461
e = 65537
n = 29869349657224745144762606999 
phi = (p - 1) * (q - 1)
d = gp.invert(e, phi)  

original_image_path = "encrypted_image.npy"
img = np.load(original_image_path, allow_pickle=True)  

img_array=img.shape
h, w, _ = img_array[0], img_array[1], img_array[2]

decrypted_array = np.zeros((h, w, 3), dtype=object) 
for i in range(h):
    for j in range(w):
        r, g, b = encrypted_img[i, j]  
        decrypted_array[i, j, 0] = gp.powmod(r, d, n)  
        decrypted_array[i, j, 1] = gp.powmod(g, d, n)
        decrypted_array[i, j, 2] = gp.powmod(b, d, n)

from PIL import Image
image = Image.fromarray(decrypted_array.astype('uint8'), 'RGB')
image.save("flag.png")

print("图片已解密并保存。")
```

![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1731417541219-acd7a91c-6897-49c2-bd17-e1a2e71970cb.png)

ISCTF{success!_bluesharkinfo_gogogo!}

### 蓝鲨的费马
[参考的博客](https://blog.csdn.net/luochen2436/article/details/129915828)

里面的(p^q+q^p)%n=p+q有点没怎么看懂，然后在一个视频的评论区里看到了一个详解（_<u>这里插入一个好玩的事，我在那个视频下面看见今年打ISCTF的有人去视频下面留言求解这道费马题的</u>_）

![](https://cdn.nlark.com/yuque/0/2024/jpeg/49639454/1731671445776-8c49d499-f360-46aa-9c81-7fdaf97265f0.jpeg)

![](https://cdn.nlark.com/yuque/0/2024/jpeg/49639454/1731671461947-57b3c1da-56ea-42f1-ac24-00ba92abacb2.jpeg)

之后是我自己的推导过程

![](https://cdn.nlark.com/yuque/0/2024/jpeg/49639454/1731417416365-843867ef-1158-4666-93cd-c57e849cd7c2.jpeg)

```plain
import gmpy2 as gp
import binascii

e=65537
c= 8989289659072309605793417141528767265266446236550650613514493589798432446586991233583435051268377555448062724563967695425657559568596372723980081067589103919296476501677424322525079257328042851349095575718347302884996529329066703597604694781627113384086536158793653551546025090807063130353950841148535682974762381044510423210397947080397718080033363000599995100765708244828566873128882878164321817156170983773105693537799111546309755235573342169431295776881832991533489235535981382958295960435126843833532716436804949502318851112378495533302256759494573250596802016112398817816155228378089079806308296705261876583997
n= 13424018200035368603483071894166480724482952594135293395398366121467209427078817227870501294732149372214083432516059795712917132804111155585926502759533393295089100965059106772393520277313184519450478832376508528256865861027444446718552169503579478134286009893965458507369983396982525906466073384013443851551139147777507283791250268462136554061959016630318688169168797939873600493494258467352326974238472394214986505312411729432927489878418792288365594455065912126527908319239444514857325441614280498882524432151918146061570116187524918358453036228204087993064505391742062288050068745930452767100091519798860487150247
leak= 9192002086528025412361053058922669469031188193149143635074798633855112230489479254740324032262690315813650428270911079121913869290893574897752990491429582640499542165616254566396564016734157323265631446079744216458719690853526969359930225042993006404843355356540487296896949431969541367144841985153231095140361069256753593550199420993461786814074270171257117410848796614931926182811404655619662690700351986753661502438299236428991412206196135090756862851230228396476709412020941670878645924203989895008014836619321109848938770269989596541278600166088022166386213646074764712810133558692545401032391239330088256431881
for k in range(1,e):
    if (e*(n+1-leak)+1)%(e-k)==0:
        phi=(e*(n+1-leak)+1)//(e-k)
        d=gp.invert(e,phi)
        m=pow(c,d,n)
        print(binascii.unhexlify(hex(m)[2:]))
```

ISCTF{u_got_it}

### 小蓝鲨的方程
一开始是想用discrete_log，运行了几分钟放弃了

上网查说bsgs算法可以优化算法，减小时间复杂度，弄了个代码

```plain
import gmpy2 as gp
import binascii
import math

def bsgs(a,c,P):
    assert math.gcd(a,P)==1
    K=int(math.ceil(P**0.5))
    right_values=dict()
    rv=c%P
    for q in range(K+1):
        right_values[rv]=q
        rv=rv*a%P
    ak=a**K%P
    for p in range(1,K+1):
        left=ak**p%P
        if left in right_values:
            q=right_values[left]
            x=K*p-q
            return x
        return None

c1= 671390498592586008552998377599101093977542184109077889081448730480869018650843045119891777468161631085086340705902115332025675787789530562679603254577287153918966364523848382506106179394235772395029788721306186952016420794804145631124905952103136061076643266886961178241381892015555099638200222249447194504082451341122502519637821695210573997670753981061458264118355417889153180841281073262935937836447460470926729282834006229571453935760593644658459098721652426154970766417292435960463905367868753821950303919781798234432998272038029063155193184039985018137026245365188171178677898869374676546799536208952198558258306460302868688355653022725288744014143221560882404431652751343944983442109327
c = 8641190030376811670503537177719719233418166235794962118828671236836174132083208517733734760455990850156371205118391537919769888760384574011411232571257192285256730733174399297826587479261381970232162702657952399683882650083181048279650913795429823628186888540572704055008102853692060360140858142686334722286525699998854566609078547487420929457446776757558492454916447188774943818970599916514467335772992690805247630814156710861067503956707301402347944233660194395192354000788262111000900574820275786269075882923600474781645848712157460135387134196156906258218217831988828360827613420801773911833194097791649069743116686685667300622630909231822986237104627385544169938138006242341269672868611269202418482629393372933567053272565557137741441902377611003983050084491513897727856173625922194300103448148829004025229567101761111396110940066254801762424343522707712480796358754008120503317686600144600226149617189681233392693738216138797012278242152852923361635415564580582002132107424154426980566696622448291815571736676562214017436
n = 1076246859437269645898003764327104347852443049519429833372038915264009774423737482018987571807662568251485615769880354898666799006772572239466617428164721157850526408878346223839884319846641438292436373441749602341461361190584638190903978829024853974880636148520803145113551453821058269641304504880310836801494499720662704717315748614372503735165114899680682056477494953525794354656896362929510309669119173103242509398650608116835276076364248473952717811633756784397347121601006659623317417388283638159905288128181587304367489096254611610975352096229116491567502061775862811850081040850421151385474249060884479729988512713640536139010928836126719149031115182144744359297169350288886555784650111
p1 = 145356063641618996012874664536921616978986640263438210169671010403677822239343590475177543891188656103067696467174379510912427160232486984044862545338401652910975162942038201716552753723984593267892098222213049269335313670049037479410635628460505327693176152061750827570561482918795206276991967169087371403553
e = 65537

P=[]
p=gp.iroot(p1-2**778,4)[0]
while p1-p**4>2**777:
    P.append(p)
    p+=1
for p in P:
    if gp.iroot(n//p,4)[1]:
        q = gp.iroot(n // p, 4)[0]
        phi = (p - 1) * (q ** 4 - 1)
        d = gp.invert(e, phi)
        s = pow(c1, d, n)
        m1 = bsgs(s**3+1,c,s**5)
        print(binascii.unhexlify(hex(m1)[2:]))
```

运行到最后好像是说存储空间不够（没截图忘了，大致好像是这样）

再去查，给了好几个方法，但感觉可行的就数学优化，一开始是想缩小模数继续用bsgs算法，但发现好像不可行，然后又想到(s<sup>3</sup>+1)<sup>m1</sup>=(2s<sup>3</sup>+1)<sup>m1//2</sup>(s<sup>3</sup>+1)<sup>m1%2</sup>=(4s<sup>3</sup>+1)<sup>m1//4</sup>(2s<sup>3</sup>+1)<sup>m1%4</sup>(s<sup>3</sup>+1)<sup>m1%2</sup>=......，推着推着突然想到了二项式展开，下面是推导过程

![](https://cdn.nlark.com/yuque/0/2024/jpeg/49639454/1731417285150-19799b5f-5200-428d-b9ea-45ecf9cc2ea8.jpeg)

```plain
import gmpy2 as gp
import binascii

c1= gp.mpz(671390498592586008552998377599101093977542184109077889081448730480869018650843045119891777468161631085086340705902115332025675787789530562679603254577287153918966364523848382506106179394235772395029788721306186952016420794804145631124905952103136061076643266886961178241381892015555099638200222249447194504082451341122502519637821695210573997670753981061458264118355417889153180841281073262935937836447460470926729282834006229571453935760593644658459098721652426154970766417292435960463905367868753821950303919781798234432998272038029063155193184039985018137026245365188171178677898869374676546799536208952198558258306460302868688355653022725288744014143221560882404431652751343944983442109327)
c = gp.mpz(8641190030376811670503537177719719233418166235794962118828671236836174132083208517733734760455990850156371205118391537919769888760384574011411232571257192285256730733174399297826587479261381970232162702657952399683882650083181048279650913795429823628186888540572704055008102853692060360140858142686334722286525699998854566609078547487420929457446776757558492454916447188774943818970599916514467335772992690805247630814156710861067503956707301402347944233660194395192354000788262111000900574820275786269075882923600474781645848712157460135387134196156906258218217831988828360827613420801773911833194097791649069743116686685667300622630909231822986237104627385544169938138006242341269672868611269202418482629393372933567053272565557137741441902377611003983050084491513897727856173625922194300103448148829004025229567101761111396110940066254801762424343522707712480796358754008120503317686600144600226149617189681233392693738216138797012278242152852923361635415564580582002132107424154426980566696622448291815571736676562214017436)
n = gp.mpz(1076246859437269645898003764327104347852443049519429833372038915264009774423737482018987571807662568251485615769880354898666799006772572239466617428164721157850526408878346223839884319846641438292436373441749602341461361190584638190903978829024853974880636148520803145113551453821058269641304504880310836801494499720662704717315748614372503735165114899680682056477494953525794354656896362929510309669119173103242509398650608116835276076364248473952717811633756784397347121601006659623317417388283638159905288128181587304367489096254611610975352096229116491567502061775862811850081040850421151385474249060884479729988512713640536139010928836126719149031115182144744359297169350288886555784650111)
p1 = gp.mpz(145356063641618996012874664536921616978986640263438210169671010403677822239343590475177543891188656103067696467174379510912427160232486984044862545338401652910975162942038201716552753723984593267892098222213049269335313670049037479410635628460505327693176152061750827570561482918795206276991967169087371403553)
e = gp.mpz(65537)

P=[]
p=gp.iroot(p1-2**778,4)[0]
while p1-p**4>2**777:
    if n%p==0:
        P.append(p)
    p+= 1

for p in P:
    if gp.iroot(n//p,4)[1]:
        q = gp.iroot(n // p, 4)[0]
        phi = (p - 1) * (q  - 1)*q**3
        d = gp.invert(e, phi)
        s = gp.mpz(pow(c1, d, n))
        m=(c-1)//s**3
        print(binascii.unhexlify(hex(m)[2:]))
```

ISCTF{8e0ff2de-cd65-497f-a755-815154bb5b1f}

# 本周学习总结
为期一周的ISCTF终于结束了，感觉还是学到了不少，就是后面会做的题都做完了后看着剩下的没思路的题就有点坐牢了。期中考顺利结束，英语的题量好多啊，感觉根本做不完，高数没有我想象中的难（ps：白紧张了，虽然但是最后也差不多是去裸考的吧），线代也是

