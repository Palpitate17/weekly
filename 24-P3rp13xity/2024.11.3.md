# 完成事项
1. BUU第二页刷完了
2. 新疆大学新生赛，SICTF
3. 看了裴蜀定理和中国剩余定理，又重新去回顾了下连分数

# 下周待做事项
1. BUU第三页
2. python
3. 复现新疆大学新生赛和SICTF
4. 数论

# 本周学习的知识分享
## BUU WP 
### bbbbbbrsa
给文件加.enc后缀，打开得到p,n,c,将c倒置用BASE 64解密得到一串数值，即c的值

```plain
import gmpy2 as gp
import binascii

p = 177077389675257695042507998165006460849
n = 37421829509887796274897162249367329400988647145613325367337968063341372726061
c = 2373740699529364991763589324200093466206785561836101840381622237225512234632
q = n//p
phi=(p-1)*(q-1)
e=70000
while e>=50000:
    while gp.gcd(e,phi)!=1:
        e-=1
    d=gp.invert(e,phi)
    m=pow(c,d,n)
    flag1=hex(m)[2:]
    if len(flag1)%2==1:
        flag1='0'+flag1
    if '{' in flag1 and '}' in flag1:
        print(binascii.unhexlify(flag1))
    e-=1
```

没弄出来，上网查了个WP，改了代码

```plain
import gmpy2 as gp
from Crypto.Util.number import *

p = 177077389675257695042507998165006460849
n = 37421829509887796274897162249367329400988647145613325367337968063341372726061
c = 2373740699529364991763589324200093466206785561836101840381622237225512234632
q = n//p
phi=(p-1)*(q-1)
e=70000
for e in range(50000,70000):
    if gp.gcd(e,phi) == 1:
       d = gp.invert(e ,phi)
       m = pow(c,d,n)
       if 'flag' in str(long_to_bytes(m)):
          print('e = ',e)
          print(long_to_bytes(m))
          break
```

### RSA
根据M2<sup>e</sup> mod N=C,爆破得到e

```plain
import gmpy2 as gp
import binascii
from Crypto.Util.number import *

c=12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120
n=13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037
M1=381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018
C=979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721
N=12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047

M2=b'BJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJD'
M2=bytes_to_long(M2)
e=1
while e<100000:
    if pow(int(M2),e,N)==C:
        break
    e+=1
print(e)
```

> e=52361
>

n=pn*q,N=pN*q,故q为n,N的公约数，pn=n//q,进而计算出m

```plain
import gmpy2 as gp
import binascii
from Crypto.Util.number import *

c=12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120
n=13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037
M1=381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018
C=979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721
N=12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047

M2=b'BJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJDBJD'
M2=bytes_to_long(M2)
e=1
while e<100000:
    if pow(int(M2),e,N)==C:
        break
    e+=1
q=gp.gcd(n,N)
p=n//q
phi=(p-1)*(q-1)
d=gp.invert(e,phi)
m=pow(c,d,n)
print(binascii.unhexlify(hex(m)[2:]))
```

flag{p_is_common_divisor}

### crypto-rsa0
由hint知压缩文件为伪加密，把所有的50 4B后的09 00都改成00 00即可打开文件

```plain
import gmpy2 as gp
import binascii

p=9018588066434206377240277162476739271386240173088676526295315163990968347022922841299128274551482926490908399237153883494964743436193853978459947060210411
q=7547005673877738257835729760037765213340036696350766324229143613179932145122130685778504062410137043635958208805698698169847293520149572605026492751740223
c = 50996206925961019415256003394743594106061473865032792073035954925875056079762626648452348856255575840166640519334862690063949316515750256545937498213476286637455803452890781264446030732369871044870359838568618176586206041055000297981733272816089806014400846392307742065559331874972274844992047849472203390350
e = 65537
n=p*q
phi=(p-1)*(q-1)
d=gp.invert(e,phi)
m=pow(c,d,n)
print(binascii.unhexlify(hex(m)[2:]))
```

flag{n0w_y0u_see_RSA}

## 1024CTF WP
### rsa_xor
对p,q进行高位剪枝爆破

```plain
def pq_high_xor(p="", q=""):
    lp, lq = len(p), len(q)
    tp0 = int(p + (512-lp) * "0", 2)
    tq0 = int(q + (512-lq) * "0", 2)
    tp1 = int(p + (512-lp) * "1", 2)
    tq1 = int(q + (512-lq) * "1", 2)

    if tp0 * tq0 > n or tp1 * tq1 < n:
        return
    if lp == leak_bits:
        pq.append(tp0)
        return

    if xor[lp] == "1":
        pq_high_xor(p + "0", q + "1")
        pq_high_xor(p + "1", q + "0")
    else:
        pq_high_xor(p + "0", q + "0")
        pq_high_xor(p + "1", q + "1")

n=48273106011030303479750559071147637692364461415670678232465061431481108973642487532471531833780197740518365642069739121637085551849041889546940626436078362563211236176786475662795558567699966699601839172948928680494946382869102384642835621200089174407697610049320667126184872014615731146641414761860081520911
leak=281061023355309655747123757605505420419083197469441023431003594867774678633816589253545604555469348502700248248380642015847706641590955340712147303939206
leak_bits = 512
xor = bin(leak)[2:].zfill(512)
pq = []

pq_high_xor('1','1')
print(pq)

import gmpy2 as gp
import binascii
p=pq[0]
q=pq[1]
e=65537
c=28821251245430906631452976417654740549504777498804891767378171423876869877729488360444250217354982452203585582130176120163935971153507066008578990196640711327843475422069941919365358328628472096529706041088538507728301864949801043519664027562401973177767449816579084825134484698353828615905989636156657341230
phi=(p-1)*(q-1)
d=gp.invert(e,phi)
m=pow(c,d,n)
print(binascii.unhexlify(hex(m)[2:]))
```

xjusec{c9c2d313-87e4-4032-95df-fba73415a850}

### e咋这么大啊
用低解密指数攻击

```plain
from Crypto.Util.number import *
from gmpy2 import *
from RSAwienerHacker import *
import libnum

n= 84759586321367337887780437584685106579085074965112521484344049646437894046082602854634633148582472968603463743438343484823980031138129314219504095698178622254320271681999860332610325223454341809051178943622128336098505461927391262429524484667385743868165220569109483345920566095908674582795138002280172054901
e= 66288875417761391735336508179031781461458397094560594352005873830730369271057472593019640848396507956317226914042734460741730619378424621998873462267141804992425548349906362051377176848446970670269625959428657063813053998204432987906270288972553991694084764963674828882833521361595114819645054140098694014033
c= 55793266382808668383390028264320313476480462639251420282032620664514843264012556336628829925417590165117761221508016231889956332919056931672687301567732943226049335108323978513326330771724845198936862017830947882511017614192627520685625693006743832632002358777752259725470367349656504917200798619000646027705

d=hack_RSA(e,n)
flag=pow(c,d,n)
print(libnum.n2s(flag))
```

xjusec{968accc5-02ee-4055-91db-986a66a10b93}

### 这个n是什么啊
分解n=1*n无法得到两个质数，设p=n,de mod phi=1=>de mod p=1,求e关于模phi的逆元d，

再根据m=c<sup>d</sup> mod n

```plain
import gmpy2 as gp
import binascii

p=gp.mpz(10003761818865136842193863045298983161361713574151191678468372633529368726046255087281418541079187460896814963538528198513877321146881615043466351212399829)
e=gp.mpz(65537)
c=gp.mpz(7499775473162852977837571721582757793922761738920542419031890111997527880067300620971290568095367411178686068031183512585634084087247376127656913662380026)
d=gp.invert(e,p-1)
m=pow(c,d,p)
print(binascii.unhexlify(hex(m)[2:]))
```

xjusec{3dfadc27-4ba0-46a0-aa9d-3d521c602760}

### pell and rsa
由题知用佩尔方程解出x,y，先暴力破解出x<sup>2</sup>-Dy<sup>2</sup>=1该佩尔方程的第一个解

```plain
D=3000
y1=1
while True:
    if (D*y1**2+1)**0.5==int((D*y1**2+1)**0.5):
        print('x1=',str(int((D*y1**2+1)**0.5)),',y1=',str(y1))
        break
    y1+=1
```

得到x1,y1

> x1= 2550251 ,y1= 46561
>

推出x<sub>n</sub>,y<sub>n</sub>代入

```plain
D=3000
y1=1
while True:
    if (D*y1**2+1)**0.5==int((D*y1**2+1)**0.5):
        x1=int((D*y1**2+1)**0.5)
        break
    y1+=1
def next_pell(x0,y0):#递归x,y
    x=x1*x0+D*y1*y0
    y=x1*y0+y1*x0
    return x,y

import gmpy2 as gp
import binascii
x=x1
y=y1
a=292215907865740405779645290989652241783683765820735541625548865510460748152214523364718188747200298811442819713371398289394755839339320662658066758126588489349
n=gp.mpz(6275980066273069860605341186607938871237382483639430889060562821040371730680653852897029157616092392778763729672341955386217885425463765034412992457381327)
c=gp.mpz(4711781113168489463053748660530912683996578583095411510495399750447704175664888661327909087124271261561192148628851409030174703875548071059738892685507459)
e=gp.mpz(65537)

while True:
    b = int(a / y) + x - n - 1
    par=(b**2-4*n)**0.5
    p, q = (-b + par) / 2, (-b - par) / 2
    if a/y==int(a/y) and par==int(par) and p==int(p):
        p,q=gp.mpz(p),gp.mpz(q)
        break
    x,y=next_pell(x,y)
phi=(p-1)*(q-1)
d=gp.invert(e,phi)
m=pow(c,d,n)
print(binascii.unhexlify(hex(m)[2:]))
```

输出了乱码，重新检查代码，发现可以直接得到phi，不用计算p,q，进而解出m

```plain
D=3000
y1=1
while True:
    if (D*y1**2+1)**0.5==int((D*y1**2+1)**0.5):
        x1=int((D*y1**2+1)**0.5)
        break
    y1+=1
def next_pell(x0,y0):#递归x,y
    x=x1*x0+D*y1*y0
    y=x1*y0+y1*x0
    return x,y

import gmpy2 as gp
import binascii
x=x1
y=y1
a=292215907865740405779645290989652241783683765820735541625548865510460748152214523364718188747200298811442819713371398289394755839339320662658066758126588489349
n=gp.mpz(6275980066273069860605341186607938871237382483639430889060562821040371730680653852897029157616092392778763729672341955386217885425463765034412992457381327)
c=gp.mpz(4711781113168489463053748660530912683996578583095411510495399750447704175664888661327909087124271261561192148628851409030174703875548071059738892685507459)
e=gp.mpz(65537)

while True:
    if a/y==int(a/y) :
        phi=a//y+x
        break
    x,y=next_pell(x,y)
d=gp.invert(e,phi)
m=pow(c,d,n)
print(binascii.unhexlify(hex(m)[2:]))
```

xjusec{ec04e6a7-0898-ffe0-9e9b-0c327746db5c}

## SICTF
### Upl0ad
编写一段PHP一句话木马

![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1730452442457-e1535c39-c7bc-4795-ad86-74c643fd8b40.png)

将后缀改为.php上传文件，显示

![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1730452515446-ad125650-5854-4feb-b1ed-b35ad703811a.png)

将后缀改为.jpg，用bp抓包，将文件类型改为php后放行

![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1730452754653-bb8b8712-4be3-4844-899b-9f42b045e726.png)

用蚁剑进行连接

![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1730452872702-21262d4d-6a9b-4d4e-987b-483d55654683.png)

打开根目录找到flag

![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1730452945333-0c16c9e4-5484-4cbd-b26d-80f5eae043cb.png)

### 派森
谐音翻译加密代码

![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1730553411524-aa90f5f1-c135-4e5a-b849-be7bf74febfd.png)

根据加密代码编写解密代码，得到flag

```plain
from Crypto.Util.strxor import strxor
a=[16, 29, 67, 84, 31, 75, 89, 48, 30, 111, 107, 48, 49, 52, 95, 67, 6, 2, 110, 51, 44, 69, 95, 118, 74, 45, 121, 95, 70, 84, 49, 49, 0, 0, 33, 33, 0, 10, 113, 125]
flag=[]
for i in range(0,len(a),4):
    flag.append(strxor(a[i].to_bytes(),a[i+2].to_bytes()))
    flag.append(strxor(a[i+1].to_bytes(),a[i+3].to_bytes()))
    flag.append(a[i+2].to_bytes())
    flag.append(a[i+3].to_bytes())
print(flag)
```

SICTF{Y0u_k0nw_Ch1n3s3_v3ry_we11!!!!qwq}

### Picture
根据加密代码编写出解密代码

```plain
from PIL import Image

flag1 = Image.open('flag1.png')
flag2 = Image.open('flag2.png')
width, height = flag1.size
image = Image.new(mode="RGB", size=flag1.size, color="white")
for i in range(width):
    for j in range(height):
        r1,g1,b1 = flag1.getpixel((i,j))
        r2,g2,b2 = flag2.getpixel((i,j))
        image.putpixel((i, j), (r1+r2,g1+g2,b1+b2))
image.save('flag.png')
```

将flag1.png和flag2.png放入装有该脚本的文件夹中，运行代码

得到flag.png,打开看见是一片空白，差点以为是自己代码有误，用画图打开该图片，将黑色随意填充入图片任意位置，显示出flag

![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1730553329451-e3e72327-b02e-45c1-9ddd-579471c597ce.png)

# 本周学习总结
python这周没看，都在打比赛做题，新疆的还行，SICTF好难，好些不会做等之后出WP了看看复现下。

